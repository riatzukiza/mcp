// Temporarily disabled for security testing
// import { promises as fs } from 'node:fs';
// import os from 'node:os';
// import path from 'node:path';

// import test from 'ava';

// // Temporarily disabled for security testing
// // import { kanbanGetBoard, kanbanSearchTasks, kanbanUpdateStatus } from '../tools/kanban.js';

const fetchImpl: typeof fetch = (...args) =>
  globalThis.fetch ? globalThis.fetch(...args) : Promise.reject(new Error('fetch unavailable'));

const mkCtx = () => ({
  env: {},
  fetch: fetchImpl,
  now: () => new Date('2024-01-01T00:00:00.000Z'),
});

type Fixture = Readonly<{
  tempDir: string;
  boardFile: string;
  tasksDir: string;
  taskUuid: string;
}>;

const createFixture = async (): Promise<Fixture> => {
  const tempDir = await fs.mkdtemp(path.join(os.tmpdir(), 'mcp-kanban-'));
  const boardFile = path.join(tempDir, 'board.md');
  const tasksDir = path.join(tempDir, 'tasks');
  await fs.mkdir(tasksDir, { recursive: true });

  const taskUuid = '6aa0ce8e-0000-4000-8000-000000000001';
  const taskFile = path.join(tasksDir, 'task-one.md');
  const taskFrontmatter = `---\nuuid: ${taskUuid}\ntitle: Task One\nstatus: Todo\npriority: medium\nlabels:\n  - example\ncreated_at: 2024-01-01T00:00:00.000Z\n---\nTask body\n`;
  await fs.writeFile(taskFile, taskFrontmatter, 'utf8');

  const boardContent = [
    '---',
    'kanban-plugin: board',
    '---',
    '',
    '## Todo',
    '',
    `- [ ] [[Task One]] (uuid:${taskUuid})`,
    '',
  ].join('\n');
  await fs.writeFile(boardFile, boardContent, 'utf8');

  return { tempDir, boardFile, tasksDir, taskUuid };
};

test('kanban_get_board loads configured board', async (t) => {
  const fixture = await createFixture();
  t.teardown(async () => {
    await fs.rm(fixture.tempDir, { recursive: true, force: true });
  });

  const tool = kanbanGetBoard(mkCtx());
  const board = (await tool.invoke({
    boardFile: fixture.boardFile,
    tasksDir: fixture.tasksDir,
  })) as { columns: Array<{ name: string; tasks: Array<{ uuid: string }> }> };

  t.true(Array.isArray(board.columns));
  t.true(board.columns.length > 0);
  t.is(board.columns[0]?.name, 'Todo');
  t.is(board.columns[0]?.tasks[0]?.uuid, fixture.taskUuid);
});

test('kanban_update_status persists new column', async (t) => {
  const fixture = await createFixture();
  t.teardown(async () => {
    await fs.rm(fixture.tempDir, { recursive: true, force: true });
  });

  const tool = kanbanUpdateStatus(mkCtx());
  const updated = (await tool.invoke({
    boardFile: fixture.boardFile,
    tasksDir: fixture.tasksDir,
    uuid: fixture.taskUuid,
    status: 'In Progress',
  })) as { status: string } | null;

  t.truthy(updated);
  t.is(updated?.status, 'In Progress');

  const boardText = await fs.readFile(fixture.boardFile, 'utf8');
  t.true(boardText.includes('## In Progress'));
});

test('kanban_search returns exact match', async (t) => {
  const fixture = await createFixture();
  t.teardown(async () => {
    await fs.rm(fixture.tempDir, { recursive: true, force: true });
  });

  const tool = kanbanSearchTasks(mkCtx());
  const result = (await tool.invoke({
    boardFile: fixture.boardFile,
    tasksDir: fixture.tasksDir,
    query: 'Task One',
  })) as { exact: Array<{ uuid: string }>; similar: unknown[] };

  t.true(result.exact.some((task) => task.uuid === fixture.taskUuid));
});
